# 고급 사용자를 위한 CLI 마스터 가이드

## Section 1: Claude Code 고급 테크닉

### 1. MCP (Model Context Protocol) 연동

Claude는 MCP를 완벽하게 지원하여, AI가 외부 데이터와 실시간으로 상호작용할 수 있습니다. 이 워크스페이스에는 4개의 핵심 MCP 서버가 통합되어 있습니다.

*   **Filesystem MCP**: 로컬 파일 시스템에 대한 전체 접근(읽기/쓰기/검색)을 제공합니다. 대용량 파일의 내용을 컨텍스트에 모두 포함하는 대신, 필요한 부분만 동적으로 분석하여 토큰을 크게 절약할 수 있습니다.
    *   **사용 예**: `"프로젝트의 모든 Python 파일에서 특정 함수 사용 부분을 찾아줘"`
*   **GitHub MCP**: GitHub 리포지토리, 이슈, PR 관리를 자동화합니다.
    *   **사용 예**: `"최신 커밋 5개의 변경사항을 요약하고, 'TODO' 키워드가 포함된 코드가 있는지 확인해줘"`
*   **SQLite MCP**: `usage.db`와 같은 로컬 SQLite 데이터베이스에 직접 쿼리를 실행하여 데이터를 분석합니다.
    *   **사용 예**: `"지난 24시간 동안 각 에이전트의 토큰 사용량과 평균 응답 시간을 알려줘"`
*   **Context7 MCP**: 최신 라이브러리 문서나 API 명세와 같은 외부 정보를 실시간으로 검색합니다. (현재는 시뮬레이션으로 동작)
    *   **사용 예**: `"requests 라이브러리의 `post` 함수 사용법에 대한 최신 예제를 찾아줘"`

### 2. 고급 워크플로우 및 최적화 패턴

*   **에이전트 간 비동기 통신**: `invoke` 명령어를 사용하여 에이전트 간에 작업을 요청하거나 상태를 공유합니다. 메시지는 `agents_hub/` 큐 시스템을 통해 전달됩니다.
    *   **사용 예**: `invoke claude.message gemini "데이터 분석 요청" "usage.db에서 어제자 사용자 활동 요약 보고서 작성해줘"`
*   **중앙 작업 관리 (`docs/HUB.md`)**: 모든 에이전트는 작업을 시작하기 전 `HUB.md`를 확인하여 다른 에이전트의 현재 작업 상태를 파악하고 충돌을 방지합니다.
*   **Windows 환경 Git 커밋 안정화**: `git commit -m "메시지"`의 문자열 처리 문제를 피하기 위해, 커밋 메시지를 임시 파일에 저장하고 `git commit -F <file>`을 사용합니다.
*   **안정적인 파일 삭제**: `del` 대신 Python의 `os.remove()` 및 `shutil.rmtree()`를 사용하여 Windows 환경에서 파일/폴더를 안정적으로 삭제합니다.
*   **`.gitignore` 우회 접근**: `respect_git_ignore=False` 옵션을 사용하여 `.gitignore`에 포함된 파일(예: 로컬 설정, 로그)에 접근합니다.
*   **자동 세션 녹화**: 환경 변수 `$env:AI_REC_AUTO=1`을 설정하면, 터미널의 모든 활동이 `terminal_logs/`에 자동으로 기록되어 작업 과정을 추적하고 복기할 수 있습니다.
*   **컨텍스트 정책 관리**: `.gemini/context_policy.yaml` 파일을 통해 각 에이전트가 접근할 수 있는 정보 소스와 토큰 제한을 정교하게 제어합니다.

### 3. 커뮤니티 베스트 프랙티스 및 실제 사용 사례

웹 리서치를 통해 확인된 실제 커뮤니티의 고급 활용 사례는 다음과 같습니다.

*   **신규 프로젝트 온보딩 가속화**: 새로운 팀에 합류했을 때, Claude CLI를 사용하여 전체 코드베이스의 아키텍처, 핵심 로직, 설정 방법을 자연어 질문으로 빠르게 파악할 수 있습니다. `.claude/` 디렉토리에 프로젝트 정보를 저장하면 Claude가 컨텍스트를 기억하여 더욱 정확한 답변을 제공합니다.

*   **대규모 리팩토링 자동화**: 레거시 시스템을 현대화하는 작업에 탁월합니다. 예를 들어, 전체 프로젝트의 클래스 기반 React 컴포넌트를 함수형 컴포넌트로 한 번에 변환하거나, 콜백 기반의 코드를 `async/await`으로 마이그레이션하는 등 복잡하고 반복적인 작업을 자동화할 수 있습니다.

*   **지능형 디버깅 및 테스트**: 애플리케이션 로그를 직접 Claude에 파이핑하여 에러의 원인을 분석하고 해결책을 제안받을 수 있습니다. (`tail -f app.log | claude -p "이 로그 스트림에서 이상 징후를 발견하면 알려줘"`) 또한, 실패하는 테스트 케이스를 제시하고 원인 분석 및 수정을 요청할 수 있습니다.

*   **DevOps 및 인프라 관리**: Nagios 모니터링 설정, Docker 컨테이너 오케스트레이션, 배포 파이프라인 생성 등 복잡한 인프라 관리 작업을 자연어 명령으로 자동화하여 효율성을 높이고 실수를 줄일 수 있습니다.

*   **외부 도구 연동을 통한 워크플로우 확장**:
    *   **웹 브라우저 제어 (Puppeteer)**: MCP를 통해 Puppeteer와 같은 도구를 연동하여 웹사이트의 정보를 스크래핑하거나, UI 테스트를 위한 스크린샷을 촬영하는 등 웹 기반 작업을 자동화합니다.
    *   **Git 워크플로우 자동화 (`SuperClaude`)**: `SuperClaude`와 같은 커뮤니티 도구를 활용하여 Conventional Commit 메시지 생성, CHANGELOG 작성, 코드 리뷰 등 Git 관련 작업을 자동화할 수 있습니다.
    *   **다중 에이전트 시스템 (`Claude Squad`)**: `Claude Squad`와 같은 도구를 사용하여 여러 AI 에이전트(예: 코딩용, 리뷰용, 리팩토링용)를 동시에 운영하는 복잡한 워크플로우를 구축할 수 있습니다.

## Section 2: Codex CLI 파워 사용법

### 1. 핵심 실행 모드 (`approval_mode`)

Codex CLI는 자율성 수준에 따라 세 가지 모드를 제공하며, `codex --<mode>` 또는 `config.yaml` 파일에서 기본값을 설정할 수 있습니다.

*   `--suggest`: (기본값) 가장 안전한 모드. 코드 변경이나 셸 명령어 실행 전에 항상 사용자 승인을 받습니다.
*   `--auto-edit`: 파일 읽기/쓰기는 자동으로 수행하지만, 셸 명령어 실행 시에는 사용자 승인을 받습니다. 리팩토링이나 코드 생성 작업에 유용합니다.
*   `--full-auto`: 파일 작업과 셸 명령어 실행 모두를 자동으로 수행합니다. 신뢰할 수 있는 작업이나 샌드박스 환경에서 사용할 때 강력한 성능을 발휘합니다.

### 2. 고급 설정 (`~/.codex/config.yaml`)

Codex의 동작을 제어하는 핵심 설정 파일입니다.

```yaml
# ~/.codex/config.yaml 예시
model: gpt-4.1
approval_mode: auto-edit
fullAutoErrorMode: ask-user
providers:
  openai:
    apikey: env:OPENAI_API_KEY
```

*   `model`: 기본으로 사용할 모델을 지정합니다. (예: `o4-mini`, `gpt-4.1`)
*   `approval_mode`: 위에서 설명한 기본 실행 모드를 설정합니다.
*   `fullAutoErrorMode`: `--full-auto` 모드에서 오류 발생 시 동작을 결정합니다. (`ask-user`: 사용자에게 질문, `ignore-and-continue`: 무시하고 계속)
*   `providers`: API 키나 다른 API 엔드포인트(`base_url`)를 설정합니다.

### 3. 지시어 파일 (Instructions)

Codex에 특정 역할을 부여하거나 일관된 스타일을 유지하도록 지시할 수 있습니다.

*   **전역 지시어 (`~/.codex/instructions.md`)**: 모든 프로젝트에 적용되는 사용자 수준의 기본 지침입니다. (예: "항상 한국어로 답변해줘", "코드는 PEP8 스타일을 따라줘")
*   **프로젝트별 지시어 (`<repo>/.codex.md`)**: 해당 프로젝트에만 적용되는 특정 지침입니다. (예: "이 프로젝트는 React와 TypeScript를 사용해", "데이터베이스 스키마는 `docs/schema.sql`을 참조해줘")

### 4. 기타 팁

*   **세션 중 모드 변경**: 대화형 세션 중에 `/mode`를 입력하여 실시간으로 실행 모드를 변경할 수 있습니다.
*   **역할 분담**: 멀티 에이전트 환경에서 Codex는 코드의 실제 구현, 버그 수정, 리팩토링과 같은 구체적인 코딩 작업에 가장 적합합니다.

ㅣ### 5. 커뮤니티 베스트 프랙티스 및 고급 활용

*   **작업에 적합한 모델 선택**: 간단하고 빠른 작업에는 `o4-mini`를, 복잡한 추론이 필요할 때는 `o3`나 `gpt-4.1` 모델을 `config.yaml`에서 지정하여 사용하면 비용과 성능의 균형을 맞출 수 있습니다.

*   **점진적인 빌드 및 테스트**: 한 번에 복잡한 애플리케이션을 통째로 빌드하도록 요청하기보다, 작고 테스트 가능한 단위로 나누어 점진적으로 개발하는 것이 성공률이 높습니다. 문제가 발생하면 디버깅을 시도하기보다, 마지막으로 작동했던 버전으로 롤백하고 다른 접근법을 시도하는 것이 더 효율적일 수 있습니다.

*   **배치(Batch) 처리를 통한 대규모 작업 자동화**:
    *   **OpenAI Batch API 활용**: 수백 개의 파일에 일관된 리팩토링을 적용하거나, 대량의 함수에 대한 단위 테스트를 생성하는 등 대규모의 비동기 작업이 필요할 때 OpenAI의 Batch API를 사용하면 표준 API 호출보다 50% 할인된 비용으로 높은 처리량의 작업을 수행할 수 있습니다.
    *   **에이전트 병렬 처리**: 최신 Codex 에이전트는 여러 독립적인 작업을 병렬로 처리할 수 있습니다. 예를 들어, 버그 수정, 신규 기능 개발, 코드베이스에 대한 질문 답변을 동시에 요청하여 개발 시간을 단축할 수 있습니다.

*   **디버깅 팁**:
    *   **환경 문제 해결**: API 키 설정, 최신 Node.js(v22+) 버전 사용, 파일 권한 문제를 가장 먼저 확인하는 것이 좋습니다. Windows 환경에서 샌드박스 관련 문제가 발생할 경우, WSL(Windows Subsystem for Linux)을 사용하는 것이 효과적인 해결책이 될 수 있습니다.
    *   **컨텍스트 한계 인지**: 모델의 컨텍스트 한계에 가까워지면 성능이 저하되거나, 테스트를 완료하지 않고도 완료했다고 보고하는 등의 환각 현상이 발생할 수 있음을 인지해야 합니다.
    *   **`codex.md`로 컨텍스트 제공**: 프로젝트 루트에 `codex.md` 파일을 만들어 프로젝트의 구조, 주요 라이브러리, 코딩 컨벤션 등 추가적인 컨텍스트를 제공하면 에이전트의 작업 정확도를 높일 수 있습니다.

## Section 3: Gemini CLI 마스터리

### 1. `invoke`를 통한 워크플로우 자동화

Gemini CLI의 가장 큰 특징은 단순한 CLI 도구를 넘어, `invoke` 태스크 시스템과 결합하여 고도로 자동화된 워크플로우를 구축한 점입니다.

*   `invoke start`: 세션 시작 시 환경 진단(`doctor`), 작업 상태 브리핑(`hub.sync`), 컨텍스트 인덱싱(`context.build`)을 한 번에 수행합니다.
*   `invoke doctor`: Python, Git, 인코딩 등 워크스페이스의 실행 환경을 점검하고 문제를 보고합니다.
*   `invoke wip`: 작업 중인 변경사항을 "Work-In-Progress" 커밋으로 안전하게 저장합니다.
*   `invoke end`: 세션 종료 시 작업 내용을 아카이빙하고 로그를 갱신합니다.

### 2. 작업 회복성 및 안정성 프로토콜

오픈소스 모델의 한계를 극복하고 안정적인 작업을 보장하기 위한 내부 프로토콜입니다.

*   **작업 분할**: 복잡한 요청은 명확한 하위 목표로 분할하여 순차적으로 처리합니다.
*   **실패 시 즉시 전환 (2-Strikes Rule)**: 동일한 접근으로 2회 연속 실패 시, 다른 해결책을 모색하여 소모적인 반복을 방지합니다.
*   **가정 명시**: 불확실한 상황에서는 명시적으로 가정을 설정하고, 이를 검증할 계획을 함께 제시하여 작업의 투명성을 높입니다.

### 3. 컨텍스트 및 보안 관리

*   **`.geminiignore`**: `.gitignore`와 유사하게, 컨텍스트에 포함되지 않을 파일 및 폴더를 지정하여 AI의 주의를 분산시키지 않고 관련 없는 정보로부터 보호합니다. (예: `node_modules/`, `*.log`)
*   **`.gemini/context_policy.yaml`**: 에이전트가 접근할 수 있는 정보 소스를 화이트리스트 방식으로 명시적으로 제어합니다.
*   **Pre-commit Hooks**: `.githooks/pre-commit` 스크립트를 통해 민감 정보(API 키, 비밀 파일)나 `projects/` 폴더의 내용이 실수로 커밋되는 것을 원천적으로 차단합니다.

### 4. 멀티모달 활용

*   Gemini CLI는 텍스트뿐만 아니라 이미지, 다이어그램 등 멀티모달 입력도 처리할 수 있습니다. (현재 워크스페이스에서는 주로 텍스트 기반으로 활용되나, 기능적으로 가능)
    *   **사용 예**: `"이 시스템 아키텍처 다이어그램(image.png)을 분석하고, 단일 실패 지점(SPOF)이 될 수 있는 부분을 알려줘"`

### 5. 커뮤니티 팁 및 고급 활용

*   **100만 토큰 컨텍스트 창의 극대화**: Gemini CLI의 가장 큰 장점은 100만 토큰에 달하는 컨텍스트 창입니다. 복잡한 작업을 요청하기 전에, 관련 코드베이스 전체를 파악하도록 유도하거나, Gemini AI Studio를 활용하여 상세한 단계별 지침을 먼저 생성하고 이를 CLI에 전달하는 고급 워크플로우를 사용하면 작업 성공률을 크게 높일 수 있습니다.

*   **멀티모달 기능 활용**:
    *   **이미지 입력**: 프롬프트에 `@` 기호와 함께 이미지 파일 경로(`@./screenshot.png`)를 포함하여 UI 목업, 스케치, 에러 스크린샷 등을 분석하고 코드 생성을 요청할 수 있습니다.
    *   **사용 예**: `"이 스케치(@./sketch.jpg)를 기반으로 웹페이지를 만들어줘."`

*   **자동화 스크립트 (`invoke` 태스크)**:
    *   이 워크스페이스에 내장된 `invoke` 태스크들은 Gemini CLI를 활용한 자동화의 좋은 예시입니다. `invoke start`(세션 시작), `invoke test`(테스트 실행), `invoke wip`(작업 저장) 등을 활용하여 반복적인 작업을 효율적으로 처리할 수 있습니다.

*   **디버깅 및 문제 해결 팁**:
    *   **`--debug` 모드**: CLI의 내부 동작을 자세히 보려면 `--debug` 플래그를 사용하세요.
    *   **서버 환경 인증**: GUI가 없는 원격 서버에서 인증 문제가 발생하면, 로컬 브라우저에서 인증 후 생성된 `localhost` URL을 `curl`이나 `wget`으로 서버에서 직접 호출하여 인증을 완료할 수 있습니다.
    *   **중요: 작업 전 커밋 필수**: 일부 사용자들이 복잡한 작업 수행 중 CLI가 예기치 않게 프로젝트를 마지막 커밋 상태로 되돌리는 현상을 보고했습니다. 중요한 작업을 수행하기 전에는 반드시 모든 변경사항을 커밋하는 것이 안전합니다.

## Section 4: 멀티 에이전트 통합 워크플로우

### 1. 역할 분담 전략

*   **Claude (총감독관)**: 복잡한 시스템 아키텍처 설계, 기술 문서 작성, 다른 에이전트의 작업 조율 등 고차원적인 추론과 계획을 담당합니다.
*   **Codex (구현 전문가)**: Claude나 Gemini가 설계한 내용을 바탕으로 실제 코드를 작성, 수정, 리팩토링하고 버그를 수정하는 데 집중합니다.
*   **Gemini (분석/자동화 전문가)**: 대량의 문서나 코드를 분석/요약하고, `invoke` 스크립트를 활용해 워크플로우를 자동화하며, 시스템의 전반적인 운영 및 유지보수를 담당합니다.

### 2. 파일 기반 비동기 통신 시스템

에이전트들은 `communication/` 폴더와 `docs/HUB.md`를 통해 서로의 작업을 확인하고 요청을 주고받습니다. 이는 직접적인 API 호출이 아닌, 파일 시스템을 매개로 한 강력하고 유연한 비동기 협업 방식입니다.

1.  **작업 할당**: Gemini가 `docs/proposals`에 분석 보고서를 작성합니다.
2.  **지시 요청**: 사용자가 이 보고서를 기반으로 외부 LLM에게 구체적인 작업 지시서를 받습니다.
3.  **실행 계획**: Gemini가 지시서를 바탕으로 `invoke` 태스크로 변환 가능한 실행 계획을 수립합니다.
4.  **구현 위임**: Gemini가 `invoke agent.msg --to codex ...` 명령으로 Codex에게 코드 구현을 요청합니다.
5.  **결과 보고**: Codex가 작업을 완료하고 `docs/HUB.md`의 상태를 'Completed'로 변경합니다.

## Section 5: 엔터프라이즈 활용 전략

*(추후 심화 연구 필요)*