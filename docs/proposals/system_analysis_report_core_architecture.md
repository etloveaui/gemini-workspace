# 시스템 심층 분석 보고서: 코어 아키텍처 및 실행 흐름

**작성자**: Gemini
**작성일**: 2025-08-18
**분석 목표**: 시스템의 핵심 실행 구조와 데이터 흐름을 분석하여 Claude가 시스템의 동작 방식을 깊이 있게 이해하도록 돕습니다.

## 1. 아키텍처 개요

이 시스템은 **PowerShell 런처**, **Invoke 태스크 프레임워크**, 그리고 **Python 스크립트 모듈**이라는 3개의 핵심 계층으로 구성된 정교한 아키텍처를 가집니다. 이는 각 계층이 명확한 책임을 갖도록 하는 **관심사 분리(Separation of Concerns)** 원칙을 잘 따르고 있습니다.

-   **프레젠테이션 계층 (PowerShell 런처)**: `gemini.ps1`, `codex.ps1`, `claude.ps1` 등의 런처 스크립트가 이 계층에 해당합니다. 사용자의 최종적인 진입점(Entry Point)으로서, 각 에이전트에 맞는 환경 변수(`ACTIVE_AGENT`)를 설정하고, 세션 기록(`Start-Transcript`)을 시작하며, 사용자의 명령을 비즈니스 로직 계층으로 전달하는 역할을 합니다.

-   **비즈니스 로직 계층 (Invoke 태스크)**: `tasks.py` 파일이 이 계층의 핵심입니다. `invoke` 프레임워크를 사용하여 `start`, `end`, `test`, `refactor` 등 사용자가 실행할 수 있는 모든 명령어를 '태스크'로 정의합니다. 각 태스크는 특정 작업을 수행하기 위한 로직을 포함하며, 실제 명령어 실행은 데이터 접근 계층에 위임합니다.

-   **데이터 접근 계층 (Python 스크립트 모듈)**: `scripts/runner.py`가 이 계층의 중심입니다. `subprocess.run`을 안전하게 감싼 `run_command` 함수를 통해 실제 셸 명령어(Git, Python 등)를 실행합니다. 또한, `scripts/usage_tracker.py`를 통해 모든 명령어 실행 기록을 `usage.db`에 로깅하는 등 시스템의 모든 하위 레벨 작업을 담당합니다.

## 2. 실행 흐름 상세 분석

사용자가 `.\gemini.ps1 start` 명령을 실행할 때의 흐름은 다음과 같습니다.

1.  **런처 실행 (`gemini.ps1`)**: PowerShell 터미널에서 `gemini.ps1` 스크립트가 실행됩니다.
2.  **환경 설정**: 스크립트 내에서 `$env:ACTIVE_AGENT = "gemini"`와 같이 현재 활성화된 에이전트를 지정하는 환경 변수가 설정됩니다.
3.  **세션 기록 시작**: `ai-rec-start.ps1`의 로직에 따라 `Start-Transcript`가 호출되어, 사용자의 모든 터미널 입출력이 `terminal_logs/` 디렉토리에 자동으로 기록되기 시작합니다.
4.  **Invoke 호출**: 런처는 사용자가 전달한 인자(`start`)를 `invoke` 명령어에 그대로 전달하여 `python -m invoke start`와 같은 형태로 Python 애플리케이션을 호출합니다.
5.  **태스크 실행 (`tasks.py`)**: `invoke`는 `tasks.py`에 정의된 `@task` 데코레이터가 붙은 함수 중 `start`라는 이름의 함수를 찾아 실행합니다.
6.  **명령어 실행 위임 (`runner.py`)**: `start` 함수는 `run_command('start.doctor', [VENV_PYTHON, 'scripts/doctor.py'])`와 같이 실제 명령어 실행을 `scripts/runner.py`의 `run_command` 함수에 위임합니다.
7.  **Subprocess 실행**: `run_command` 함수는 `subprocess.run`을 사용하여 `scripts/doctor.py`를 별도의 프로세스로 실행합니다. 이때 `shell=False`를 유지하여 보안을 강화하고, `PYTHONIOENCODING=utf-8` 환경 변수를 설정하여 인코딩 문제를 방지합니다.
8.  **결과 반환 및 로깅**: `subprocess.run`의 실행 결과(stdout, stderr, returncode)는 `run_command` 함수로 반환됩니다. 만약 오류가 발생하면, `_log_event` 함수를 통해 `usage.db`에 상세한 오류 내용이 기록됩니다.
9.  **세션 종료**: 사용자가 `invoke end`를 실행하거나 런처 스크립트가 종료되면, `Stop-Transcript`가 호출되어 세션 기록이 안전하게 종료됩니다.

## 3. 분석 및 평가

-   **강점**:
    -   **모듈성 및 확장성**: 각 기능이 독립적인 스크립트로 분리되어 있어 새로운 기능을 추가하거나 기존 기능을 수정하기 용이합니다. 새로운 에이전트를 추가하는 작업은 런처 스크립트 하나를 추가하고, 필요에 따라 `tasks.py`에 몇 가지 태스크를 추가하는 것만으로 가능합니다.
    -   **안정성 및 재현성**: `runner.py`를 통해 모든 명령어 실행이 중앙에서 관리되고 로깅되므로, 문제 발생 시 원인을 추적하기 쉽습니다. 또한, 모든 세션이 기록되므로 작업 내용을 재현하고 검토하는 데 매우 유리합니다.
    -   **에이전트 시스템에 최적화**: `ACTIVE_AGENT` 환경 변수를 통해 각 에이전트의 역할을 명확히 분리하면서도, `invoke`라는 단일 인터페이스를 통해 일관된 사용자 경험을 제공하는 점이 돋보입니다.

-   **잠재적 개선점**:
    -   **플랫폼 종속성**: 현재 아키텍처는 PowerShell에 대한 의존성이 높아 Windows 환경에 최적화되어 있습니다. 향후 다른 OS(Linux, macOS)를 지원하려면 런처 및 세션 기록 부분을 셸 스크립트나 Python 코드로 대체하는 작업이 필요할 수 있습니다.
    -   **초기 학습 곡선**: 시스템의 구성 요소가 많고 계층이 명확하게 나뉘어 있어, 처음 시스템을 접하는 개발자는 전체 실행 흐름을 파악하는 데 다소 시간이 걸릴 수 있습니다. 아키텍처 다이어그램과 같은 시각 자료가 있다면 이해에 큰 도움이 될 것입니다.

## 4. 결론

이 시스템의 코어 아키텍처는 매우 잘 설계되어 있으며, 특히 다중 에이전트 환경에서의 안정성, 확장성, 재현성을 높은 수준으로 확보하고 있습니다. Claude가 이 구조를 이해한다면, 시스템의 다른 에이전트들과 원활하게 협업하고, 새로운 기능을 안전하게 추가하며, 문제 발생 시 효과적으로 대응할 수 있을 것입니다.
