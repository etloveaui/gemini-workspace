# 제안서: [P1-2] 파일 시스템 에이전트 업그레이드: 프로토타입에서 프레임워크로

**문서 버전:** 1.0
**작성일:** 2025-08-07

## 1. 프로젝트 비전

본 프로젝트의 목표는 현재의 단일 파일 스크립트인 `file_agent.py`를, **새로운 코드 수정 규칙을 플러그인처럼 쉽게 추가하고 안전하게 테스트할 수 있는, 확장 가능한 "지능형 코드베이스 관리 프레임워크"로 진화**시키는 것입니다. 최종적으로는 "주요 함수의 반환 타입을 힌트로 추가해줘"와 같은 자연어 명령을 이해하고, 해당 규칙을 동적으로 적용하여 복잡한 코드 리팩토링을 수행하는 것을 지향합니다.

## 2. 현재 상태 및 핵심 한계

### 2.1. 현재 구현 (As-Is)

`scripts/file_agent.py`는 `[P1-2]` 계획의 핵심 아이디어를 성공적으로 증명한 프로토타입입니다.

- **핵심 기술 검증:** Python의 `ast` 모듈을 사용한 코드 파싱 및 재작성, `difflib`을 이용한 변경 내용(diff) 생성, `--dry-run`을 통한 안전장치 등 기본 골격은 이미 구현되어 있습니다.
- **기능:** 현재 "docstring 추가"라는 단일 리팩토링 규칙을 수행할 수 있습니다.

### 2.2. 치명적인 한계 (핵심 문제)

현재 프로토타입은 **확장성**과 **유지보수성** 면에서 치명적인 한계를 가지고 있습니다.

- **하드코딩된 규칙 처리:** 새로운 리팩토링 규칙(예: `rename_variable`)을 추가하려면, `file_agent.py`의 `main` 함수 내부에 아래와 같이 `if/elif/else` 구문을 계속해서 추가해야 합니다.

  ```python
  # 현재 file_agent.py의 문제적 구조
  def main():
      # ...
      if args.rule == "add_docstrings":
          new_code = add_docstrings(source_code)
      # 새로운 규칙을 추가하려면 여기에 elif를 계속 추가해야 함
      # elif args.rule == "rename_variable":
      #     new_code = rename_variable(source_code, old_name, new_name)
      else:
          print(f"Error: Unknown rule '{args.rule}'")
          sys.exit(1)
      # ...
  ```

  이 구조는 새로운 규칙이 추가될 때마다 메인 로직을 수정해야 하므로 OCP(개방-폐쇄 원칙)를 위반하며, 코드를 복잡하고 오류에 취약하게 만듭니다.

- **테스트 부재:** `tests/test_p1_file_agent.py`가 존재하지 않아, 코드 변경 시 안정성을 검증할 자동화된 수단이 없습니다.

## 3. 목표 아키텍처 (To-Be)

이러한 한계를 극복하기 위해, **규칙을 동적으로 로드하고 적용하는 플러그인 기반 아키텍처**를 도입합니다.

### 3.1. 목표 디렉터리 구조

```
scripts/
├── agents/
│   ├── __init__.py
│   ├── file_agent.py         # 메인 엔진 (수정됨)
│   └── rules/
│       ├── __init__.py         # 규칙 레지스트리
│       ├── add_docstrings.py   # 규칙 1 (모듈화됨)
│       └── rename_variable.py  # 규칙 2 (새로 추가될 예시)
└── utils/
    └── diff.py
```

### 3.2. 동작 흐름

1.  `invoke refactor --rule <rule_name>` 실행
2.  `file_agent.py`는 `scripts/agents/rules/__init__.py`의 `get_rule` 함수를 호출합니다.
3.  `get_rule` 함수는 `RULES` 딕셔너리에서 `<rule_name>`에 해당하는 규칙 모듈을 찾아 반환합니다.
4.  `file_agent.py`는 반환된 모듈의 `run` 함수를 실행하여 리팩토링을 수행합니다.

이 구조를 통해, 새로운 규칙을 추가할 때는 `rules` 디렉터리에 새 Python 파일만 추가하면 되므로, 메인 엔진(`file_agent.py`)을 전혀 수정할 필요가 없습니다.

## 4. 구체적인 실행 계획 (Action Plan)

1.  **디렉터리 구조 생성:** `scripts/agents/` 및 `scripts/agents/rules/` 디렉터리를 생성합니다.
2.  **규칙 레지스트리 구현:** `scripts/agents/rules/__init__.py`에 `RULES` 딕셔너리와 `get_rule` 함수를 구현합니다.
3.  **기존 규칙 모듈화:** `file_agent.py`에 있던 `add_docstrings` 로직을 `scripts/agents/rules/add_docstrings.py` 파일로 분리하고, `run(tree)` 인터페이스를 준수하도록 수정합니다.
4.  **메인 엔진 리팩토링:** `file_agent.py`의 `main` 함수에서 `if/else` 분기문을 제거하고, `get_rule(args.rule).run(tree)`를 호출하여 동적으로 규칙을 적용하도록 수정합니다.
5.  **안전장치 강화:** 사용자의 명시적 동의 없이는 파일이 수정되지 않도록, `--apply` 또는 `--yes` 플래그가 있을 때만 실제 파일 쓰기를 수행하는 로직을 추가합니다.
6.  **테스트 하네스 구축:** `tests/test_p1_file_agent.py`를 생성하고, 다음을 포함한 `pytest` 테스트 케이스를 작성합니다.
    - **Dry-Run 검증:** `--dry-run` 실행 시, 파일 내용이 변경되지 않고 `diff`만 출력되는지 확인합니다.
    - **Apply 검증:** `--apply` 실행 시, 파일 내용이 의도대로 변경되는지 확인합니다.
    - **규칙 로딩 검증:** 존재하지 않는 규칙을 요청할 때, 적절한 오류를 발생시키는지 확인합니다.
    - **예외 처리 검증:** 문법 오류가 있는 파일을 대상으로 실행 시, 안전하게 종료되는지 확인합니다.
7.  **문서화:** `docs/HELP.md`에 새로운 프레임워크의 사용법과 **"새로운 리팩토링 규칙을 추가하는 방법"**에 대한 상세한 가이드를 추가합니다.

## 5. 다른 LLM을 위한 핵심 질문

이 프로젝트를 성공적으로 수행하기 위해, 다른 전문가(LLM)들의 의견을 구합니다.

1.  **아키텍처:** 제시된 플러그인 아키텍처(규칙 레지스트리 패턴)보다 더 효율적이거나 Pythonic한 설계 패턴이 있다면 제안해 주십시오. (예: `setuptools`의 `entry_points` 활용, 클래스 기반 규칙 상속 구조 등)
2.  **AST 조작:** Python의 `ast` 모듈을 직접 다룰 때 발생할 수 있는 잠재적 위험(예: 주석, 빈 줄, 기존 포맷팅 유실)을 최소화하기 위한 Best Practice나 추천 라이브러리(`libcst` 등)가 있다면 알려주십시오.
3.  **미래 확장성:** 향후 "이 함수를 비동기로 바꿔줘"와 같은 자연어 명령을 AST 변환 규칙으로 자동 생성하는 기능을 구현하려면, 현재 설계에서 어떤 점을 미리 고려해야 합니까? (예: 규칙 생성 프롬프트 템플릿, AST 노드 타입과 자연어 매핑 등)

---
