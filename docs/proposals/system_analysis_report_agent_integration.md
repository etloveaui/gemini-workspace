# 시스템 심층 분석 보고서: 에이전트 통합 및 협업 프로토콜

**작성자**: Gemini
**작성일**: 2025-08-18
**분석 목표**: 시스템 내 다중 에이전트(Gemini, Codex, Claude)가 어떻게 식별되고, 상호작용하며, 작업을 협업하는지에 대한 프로토콜을 분석합니다.

## 1. 에이전트 식별 및 활성화 메커니즘

시스템은 **환경 변수 우선**의 명확한 원칙에 따라 현재 활성 에이전트를 식별합니다.

-   **1순위 (프로세스 레벨)**: `ACTIVE_AGENT` 환경 변수가 최우선 순위를 가집니다. `gemini.ps1`, `codex.ps1` 같은 런처 스크립트는 각자 자신의 에이전트 이름으로 이 변수를 설정하여, 해당 터미널 세션 동안의 모든 작업이 특정 에이전트의 컨텍스트에서 실행되도록 보장합니다. 이는 세션별로 독립적인 에이전트 컨텍스트를 유지할 수 있게 하는 핵심적인 기능입니다.

-   **2순위 (전역 레벨)**: `ACTIVE_AGENT` 환경 변수가 없을 경우, `scripts/agent_manager.py`는 `.agents/config.json` 파일에 정의된 `active` 값을 읽어 전역 기본값으로 사용합니다. 이 설정은 `invoke agent.set [에이전트명]` 명령어를 통해 사용자가 직접 변경할 수 있습니다.

-   **사용자 인터페이스**: `invoke agent.status`와 `invoke agent.set` 태스크는 사용자가 현재 활성 에이전트를 쉽게 확인하고 변경할 수 있는 편리한 인터페이스를 제공합니다.

## 2. 에이전트 협업 프로토콜

이 시스템은 두 가지 주요 채널을 통해 에이전트 간의 협업을 지원합니다.

### 가. 비공식적 통신: 공유 메시지 로그 (`context/messages.jsonl`)

-   **목적**: 에이전트 간의 일반적인 정보 공유, 상태 보고, 간단한 요청 등을 위한 비공식적 통신 채널입니다.
-   **메커니즘**: `invoke agent.msg` 명령어를 사용하면, `scripts/agents/messages.py`가 타임스탬프, 발신자, 수신자, 메시지 본문, 태그를 포함한 JSON 객체를 `context/messages.jsonl` 파일에 추가(append)합니다. 이는 모든 에이전트가 구독하는 일종의 **공개 채널(Public Channel)** 또는 **이벤트 로그(Event Log)** 와 유사하게 작동합니다.
-   **장점**: 구현이 매우 간단하고, 모든 통신 기록이 한 곳에 순차적으로 저장되므로 전체 대화의 흐름을 파악하기 용이합니다.

### 나. 공식적 작업 할당: 파일 기반 태스크 큐 (`agents_hub/`)

-   **목적**: 특정 에이전트에게 공식적으로 작업을 할당하고, 그 처리 상태를 추적하기 위한 구조화된 통신 채널입니다.
-   **메커니즘**: `invoke hub.send`를 통해 특정 에이전트에게 작업을 할당하면, 해당 작업은 `agents_hub/queue/`에 JSON 파일로 생성됩니다. 대상 에이전트는 `invoke hub.claim`으로 작업을 가져가 `processing` 상태로 변경하고, 완료 후 `invoke hub.complete`를 통해 `archive`로 이동시킵니다. (상세 내용은 "상태 관리 및 데이터 흐름" 보고서 참조)
-   **장점**: 작업의 라이프사이클(대기 → 처리 중 → 완료/실패)이 명확하게 관리되므로, 복잡한 작업을 안정적으로 핸드오프할 수 있습니다.

## 3. 파일 수정 프로토콜: 규약인가, 강제인가?

-   **명시된 규약**: `GEMINI.md` 문서에는 "시스템 파일의 직접 수정은 원칙적으로 Codex 에이전트가 전담한다"고 명시되어 있습니다.
-   **분석 결과**: 현재 시스템에는 **이 규약을 기술적으로 강제하는 메커니즘이 존재하지 않습니다.** `refactor`나 `edits`와 같은 파일 수정 관련 태스크들은 모든 에이전트가 사용할 수 있는 범용 도구로 구현되어 있습니다.
-   **결론**: "파일 수정 프로토콜"은 코드 레벨에서 강제되는 규칙이 아닌, 개발팀의 **사회적 합의 또는 협업 규약(Social Contract or Convention)** 입니다. 이는 시스템의 유연성을 높이는 장점이 있지만, 모든 에이전트 개발자가 이 규약을 인지하고 준수하지 않으면 일관성이 깨질 위험이 있습니다.

## 4. 분석 및 평가

-   **강점**:
    -   **다층적 통신**: 비공식적 채널과 공식적 채널을 모두 제공하여, 상황에 맞는 유연한 협업이 가능합니다.
    -   **상태 투명성**: 모든 통신과 작업 할당이 파일 기반으로 이루어져, 시스템의 현재 상태를 명확하게 파악하고 디버깅하기 쉽습니다.
    -   **느슨한 결합**: 에이전트들은 서로의 내부 구현을 알 필요 없이, 정의된 메시지와 태스크 큐를 통해 상호작용하므로 시스템의 확장성이 높습니다.

-   **잠재적 개선점**:
    -   **프로토콜 강제성 부재**: 파일 수정과 같은 중요한 프로토콜이 규약에만 의존하고 있어, 향후 에이전트가 추가되거나 개발자가 변경될 경우 혼란이 발생할 수 있습니다. `pre-commit hook`이나 특정 태스크 실행 시 에이전트 권한을 확인하는 로직을 추가하여 이를 보완할 수 있습니다.
    -   **에이전트 능력 검색(Discovery)의 부재**: 현재 시스템에는 어떤 에이전트가 어떤 능력을 가지고 있는지(예: `refactor` 전문, `search` 전문 등)를 알려주는 중앙 레지스트리가 없습니다. 향후 에이전트가 많아지면, 특정 작업을 어떤 에이전트에게 맡겨야 할지 판단하기 어려워질 수 있습니다.

## 5. 결론

이 시스템의 에이전트 통합 및 협업 프로토콜은 매우 실용적이고 유연하게 설계되어 있습니다. Claude는 이 프로토콜을 이해함으로써, `ACTIVE_AGENT` 컨텍스트의 의미를 파악하고, `agent.msg`와 `hub.send`를 적절히 사용하여 다른 에이전트와 효과적으로 소통하고 작업을 분담할 수 있을 것입니다. 특히, 파일 수정과 같은 중요한 작업은 현재 규약에 따라 Codex에게 요청하는 방식으로 협업하는 것이 권장됩니다.