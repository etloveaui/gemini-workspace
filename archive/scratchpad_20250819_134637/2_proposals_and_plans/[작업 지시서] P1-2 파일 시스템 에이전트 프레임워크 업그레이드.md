알겠습니다. 두 문서를 종합적으로 분석하여, 제미나이 CLI가 즉시 착수할 수 있도록 상세하고 구체적인 **작업 지시서**를 작성했습니다.

-----

## **[작업 지시서] P1-2 파일 시스템 에이전트 프레임워크 업그레이드**

**TO:** Gemini CLI
**FROM:** Project Manager
**DATE:** 2025-08-08
**RE:** `P1-2_File_Agent_Framework_Upgrade.md` 및 Tech Expert 분석 결과 기반 실행 계획

### **1. 프로젝트 최종 목표 (End-Goal)**

기존의 `if/else` 기반 단일 스크립트(`file_agent.py`)를 폐기하고, **"규칙(Rule)이 클래스로 정의되고, 자동으로 시스템에 등록되며, 안전장치가 내장된" 지능형 코드 리팩토링 프레임워크를 구축**한다. 이 프레임워크는 Tech Expert의 권고안을 전면 수용하여 확장성, 안정성, 유지보수성을 극대화하는 것을 목표로 한다.

### **2. 단계별 실행 계획 (Phased Action Plan)**

아래 명시된 단계별 과업을 순서대로 수행하여, 48시간 내 최소 기능 제품(MVP) 완성을 목표로 한다.

-----

### **Phase 1: 코어 아키텍처 리팩토링 (8시간)**

**목표:** 기존 프로토타입의 `if/else` 구조를 제거하고, 클래스 기반의 동적 규칙 로딩 아키텍처를 도입한다.

#### **과업 1.1: 'RuleBase' 추상 클래스 및 자동 등록 메커니즘 구현**

  - **지시:** 모든 규칙의 청사진이 될 `RuleBase` 클래스를 `scripts/agents/rules/base.py`에 생성한다.
  - **요구사항:**
    1.  `__init_subclass__`를 사용하여, `RuleBase`를 상속하는 모든 클래스가 `RuleBase.registry` 딕셔너리에 자동으로 등록되도록 구현한다. `name` 속성을 기본 키로 사용하며, 없을 경우 클래스 이름을 사용한다.
    2.  모든 규칙이 구현해야 할 필수 인터페이스와 메타데이터 필드를 `RuleBase`에 정의한다.
          - `apply(self, source: str, **kwargs) -> str`: 실제 변환 로직을 수행하는 추상 메서드.
          - `name: str`: CLI에서 사용할 규칙의 고유 이름.
          - `summary: str`: `--list` 옵션에 표시될 규칙의 한 줄 요약.
          - `idempotent: bool`: 규칙의 멱등성 여부 (기본값: `True`). 멱등성이란 규칙을 여러 번 적용해도 한 번 적용한 것과 결과가 같은 성질을 의미한다.
          - `conflicts: set[str]`: 함께 실행될 수 없는 다른 규칙 이름의 집합 (초기에는 빈 집합).
  - **실행 코드 (참고):**
    ```python
    # scripts/agents/rules/base.py
    class RuleBase:
        registry: dict[str, type["RuleBase"]] = {}
        name: str = ""
        summary: str = ""
        idempotent: bool = True
        conflicts: set[str] = set()

        def __init_subclass__(cls, **kwargs):
            super().__init_subclass__(**kwargs)
            # 'name' 속성이 정의되지 않은 경우 클래스 이름을 사용
            rule_name = getattr(cls, "name", cls.__name__)
            if rule_name and rule_name != "RuleBase":
                 cls.registry[rule_name] = cls

        def apply(self, source: str, **kwargs) -> str:
            raise NotImplementedError("각 규칙은 apply 메서드를 반드시 구현해야 합니다.")
    ```

#### **과업 1.2: `pkgutil`을 이용한 규칙 동적 로딩 기능 구현**

  - **지시:** `scripts/agents/rules/__init__.py`에 `rules` 디렉터리 내의 모든 규칙 모듈을 자동으로 임포트하여 `RuleBase.registry`를 채우는 로더를 구현한다.
  - **요구사항:**
      - `pkgutil.iter_modules`를 사용하여 `scripts/agents/rules` 패키지 내의 모든 `*.py` 파일을 동적으로 임포트한다. 이 로직은 `file_agent.py`가 실행될 때 호출되어야 한다.
  - **실행 코드 (참고):**
    ```python
    # scripts/agents/rules/__init__.py
    import importlib
    import pkgutil

    def load_rules():
        """'rules' 패키지 내의 모든 모듈을 동적으로 임포트하여 Rule 클래스들을 등록합니다."""
        # __path__와 __name__을 이용하여 현재 패키지를 기준으로 모듈을 찾음
        for _, name, _ in pkgutil.iter_modules(__path__, __name__ + "."):
            importlib.import_module(name)

    # 이 __init__.py 파일이 로드될 때 모든 규칙을 로드
    load_rules()
    ```

#### **과업 1.3: 기존 'add\_docstrings' 규칙을 `RuleBase` 기반 클래스로 마이그레이션**

  - **지시:** `scripts/agents/rules/add_docstrings.py` 파일을 생성하고, 기존 `file_agent.py`에 있던 docstring 추가 로직을 이곳으로 옮겨 `RuleBase`를 상속하는 클래스로 재작성한다.
  - **요구사항:**
      - `AddDocstringsRule` 클래스를 정의하고 `RuleBase`를 상속한다.
      - `name = "add_docstrings"` 와 `summary = "함수/클래스에 docstring을 추가합니다."` 메타데이터를 명시한다.
      - `apply(self, source: str, **kwargs) -> str` 메서드 내부에 `ast`를 이용한 코드 변환 및 재작성 로직을 구현한다.

-----

### **Phase 2: CLI/UX 및 안전장치 강화 (16시간)**

**목표:** 사용자가 프레임워크를 안정적으로 사용하고 쉽게 확장할 수 있도록 CLI를 개선하고, 치명적인 오류를 방지할 안전장치를 3중으로 구축한다.

#### **과업 2.1: CLI 인터페이스 고도화**

  - **지시:** `argparse` 또는 `typer`를 사용하여 CLI 명령어를 직관적으로 개선한다.
  - **요구사항:**
      - `invoke refactor --list`: `RuleBase.registry`를 조회하여 사용 가능한 모든 규칙의 `name`과 `summary`를 출력한다.
      - `invoke refactor --explain <rule_name>`: 지정된 규칙의 상세 정보(docstring, 멱등성 여부 등)를 출력한다.
      - `invoke refactor <file_path> --rule <rule_name> [--apply]`:
          - `--apply` 플래그가 없으면 **반드시 `--dry-run` 모드로 동작**하여 변경될 내용(diff)만 출력하고 실제 파일은 수정하지 않는다.
          - `--apply` 플래그가 있을 때만 사용자에게 확인 후 또는 즉시 파일에 변경 사항을 적용한다.
      - **Diff 출력 개선:** `rich` 라이브러리를 사용하여 diff 출력을 색상으로 구분하고, 추가/삭제된 라인 수를 요약하여 가시성을 높인다. 이 로직은 공통 함수로 분리한다.

#### **과업 2.2: 3중 안전장치(Safety Trinity) 구축**

  - **지시:** 사용자의 실수를 방지하고 시스템 안정성을 보장하는 핵심 안전 로직을 구현한다.
  - **요구사항:**
    1.  **작업 경계 강제 (Boundary Enforcement):**
          - **절대 경로 및 상위 디렉터리 접근 차단:** 사용자가 지정한 파일 경로가 현재 프로젝트 작업 공간(ROOT)을 벗어나는지 확인한다. 벗어날 경우, 오류 메시지를 출력하고 즉시 종료한다(종료 코드: `4`).
          - **실행 코드 (참고):**
            ```python
            # ROOT는 프로젝트 최상위 디렉터리 경로
            final_path = (ROOT / args.file).resolve()
            if ROOT.resolve() not in final_path.parents:
                print(f"오류: '{final_path}' 경로는 워크스페이스 외부입니다.")
                sys.exit(4)
            ```
    2.  **실행 취소 보장 (Undo Guarantee):**
          - `--apply`로 파일을 수정하기 직전, 원본 파일의 복사본을 `.bak` 확장자로 생성하거나 `git stash --include-untracked`를 사용하여 작업 내역을 임시 저장한다.
          - 만약 규칙 적용 중 오류가 발생하면, 저장해둔 백업을 이용해 자동으로 원상 복구하고 사용자에게 상황을 알리는 로직을 표준화한다.
    3.  **멱등성 계약 (Idempotency Contract):**
          - 모든 규칙은 `idempotent = True`를 기본값으로 가지며, 이는 \*\*"두 번 실행해도 결과가 한 번 실행한 것과 같아야 함"\*\*을 의미한다.
          - 테스트 케이스 작성 시, 모든 규칙에 대해 **1회 적용한 결과와 2회 적용한 결과를 비교**하여 동일함을 검증하는 테스트를 **필수**로 포함한다.

-----

### **Phase 3: 품질 보증 및 문서화 (24시간)**

**목표:** 프레임워크의 신뢰도를 높이고, 다른 개발자가 쉽게 새로운 규칙을 추가할 수 있도록 테스트와 문서를 완비한다.

#### **과업 3.1: "규칙-중심" 테스트 하네스 구축**

  - **지시:** `pytest`를 사용하여 `tests/test_p1_file_agent.py`에 상세한 테스트 케이스를 작성한다.
  - **요구사항:**
      - **단위 테스트 (규칙별):**
          - **정상 케이스:** 각 규칙에 대해 '입력 코드' -\> '예상 출력 코드' 스냅샷 테스트를 작성한다.
          - **멱등성 테스트:** 모든 규칙을 한 파일에 두 번 연속 적용하여 결과가 변하지 않음을 검증한다.
          - **예외 처리 테스트:** 문법 오류가 있는 Python 파일을 입력했을 때, 프레임워크가 비정상 종료되지 않고 안전하게 오류를 보고하는지 확인한다.
      - **통합 테스트 (CLI 동작):**
          - `--dry-run` 명령 시 파일이 절대 변경되지 않고 diff만 출력되는지 검증한다.
          - `--apply` 명령 시 파일 내용이 의도대로 변경되는지 검증한다.
          - 존재하지 않는 규칙을 요청할 때 적절한 오류 메시지와 종료 코드를 반환하는지 확인한다.
          - 작업 경계(Boundary)를 벗어나는 파일을 대상으로 실행 시 거부되는지 확인한다.
      - **CI 게이트:** GitHub Actions 등 CI 환경에서 `pytest -q`가 통과하는 것을 Pull Request 머지의 필수 조건으로 설정한다.

#### **과업 3.2: 개발자 및 사용자 문서 작성**

  - **지시:** `docs/HELP.md` 파일을 생성하고 프레임워크 사용법 및 확장 방법을 상세히 기술한다.
  - **요구사항:**
      - **사용자 가이드:** `--list`, `--explain`, `--apply` 등 모든 CLI 옵션의 사용법을 예시와 함께 설명한다.
      - **개발자 가이드 (가장 중요):**
          - **"새로운 리팩토링 규칙 추가하는 방법"** 튜토리얼을 작성한다.
          - 튜토리얼에는 `RuleBase` 상속, 필수 메타데이터(`name`, `summary` 등) 설정, `apply` 메서드 구현, 멱등성 고려사항, 테스트 케이스 추가까지의 전 과정이 포함되어야 한다.

-----

### **4. 장기 로드맵 (Post-MVP)**

  - **1단계 (단기):** 위 지시서의 Phase 1-3을 완수하여 안정적인 `ast` 기반 프레임워크를 출시한다.
  - **2단계 (중기):** 주석과 코드 포맷팅 보존이 완벽한 `LibCST`로의 점진적 전환을 계획하고, 복잡한 규칙은 `LibCST`로만 작성하도록 가이드한다.
  - **3단계 (장기):** `setuptools`의 `entry_points`를 도입하여 외부 개발자가 pip로 규칙을 설치할 수 있는 진정한 플러그인 생태계를 구축하고, 자연어 명령 처리를 위한 LLM 연동을 연구한다.

**이상. 즉시 과업에 착수해주기 바랍니다.**